URP协议实现报告

课程：COMP3331/9331 计算机网络与应用
作业：基于UDP的可靠传输协议（URP）
编程语言：Python 3

================================================================================

1. 代码组织

实现包含两个主要的Python文件：

- sender.py：实现URP发送方，包含PLC（丢包和损坏）模块
- receiver.py：实现URP接收方

两个文件都是自包含的，包含所有必要功能：
- 协议状态机实现
- 日志记录和统计信息跟踪

除了Python 3标准库模块（socket, sys, time, threading, struct, random）外，无需其他依赖。

================================================================================

2. 整体程序设计

2.1 架构

实现采用模块化设计，职责分离清晰：

发送方（sender.py）：
- PLC模块：模拟丢包和损坏的PLC类
- URP发送方：实现协议状态机的URPSender类
- 多线程：用于重传定时器管理的独立线程

接收方（receiver.py）：
- URP接收方：实现接收方状态机的URPReceiver类
- 多线程：用于TIME_WAIT状态管理的独立线程

两个程序都实现了符合规范的URP段格式（6字节头部，包含序列号、标志位和校验和），并正确使用网络字节序。

2.2 状态机

发送方状态：
CLOSED -> SYN_SENT -> ESTABLISHED -> FIN_SENT -> CLOSED

接收方状态：
CLOSED -> LISTEN -> ESTABLISHED -> TIME_WAIT -> CLOSED

2.3 关键设计决策

1. 单一定时器：发送方为最老的未确认段维护一个定时器，符合TCP风格实现
2. 滑动窗口：使用字典缓冲未确认的段
3. 增量文件I/O：增量读写文件以高效处理大文件
4. 乱序缓冲：接收方缓冲乱序段直到填补空缺

================================================================================

3. 错误检测机制

实现使用16位反码校验和，类似于TCP/UDP。

3.1 校验和算法

校验和计算过程：
1. 处理段中所有16位字（奇数长度时用0填充）
2. 对所有字求和，处理溢出（将进位位加回）
3. 对结果取反码

这确保接收方重新计算包括接收到的校验和字段时，结果应为0xFFFF。

3.2 验证过程

1. 发送方：传输前计算校验和（校验和字段置0）
2. 接收方：到达时重新计算校验和并与接收值比较
3. 损坏段：丢弃，不进行进一步处理或生成ACK

该机制可可靠检测单比特错误和大多数多比特错误（在头部和载荷中）。

================================================================================

4. 数据结构设计

4.1 发送方数据结构

滑动窗口管理：
- window：字典 {seq_num: (segment_data, payload_len, send_time)}
- unacked_bytes：跟踪传输中的字节数
- base：窗口左边界（最小未确认序列号）
- next_seq：下一个要发送的序列号

快速重传：
- dup_ack_count：字典 {ack_num: count} 跟踪重复ACK
- last_ack：最后接收的ACK号

定时器管理：
- oldest_unacked_seq：最老未确认段的序列号
- timer_running：定时器状态标志

4.2 接收方数据结构

乱序段接收缓冲区：
- buffer：字典 {seq_num: payload} 存储乱序段
- received_bytes：集合，跟踪已接收字节范围用于重复检测
- expected_seq：下一个期望的序列号

4.3 设计理由

- 基于字典的缓冲区：段的O(1)查找和插入
- 集合用于重复检测：已接收字节范围的快速成员测试
- 线程安全锁：保护多线程定时器操作中的共享状态

================================================================================

5. 发送方操作

5.1 连接建立

1. 生成随机ISN（0到65535）
2. 发送SYN段，进入SYN_SENT状态
3. 启动重传定时器
4. 等待ACK(ISN+1)
5. 超时则重传SYN
6. 收到有效ACK，进入ESTABLISHED状态

5.2 数据传输

窗口管理：
- 检查可用窗口空间（unacked_bytes < max_win）
- 从文件读取最多MSS字节
- 创建具有适当序列号的DATA段
- 通过PLC模块发送
- 在窗口字典中缓冲段

定时器管理：
- 发送第一个段时启动定时器（如果未运行）
- 定时器跟踪最老的未确认段
- 超时：重传最老的段，重启定时器

ACK处理：
- 验证校验和
- 如果有效且确认新数据：
  * 更新base（窗口前移）
  * 从缓冲区移除已确认的段
  * 如果仍有未确认段，重启定时器
- 如果是重复ACK：
  * 增加重复ACK计数器
  * 第3个重复时：快速重传最老的未确认段

5.3 连接终止

1. 所有数据确认后，发送FIN段
2. 进入FIN_SENT状态，启动定时器
3. 等待FIN ACK
4. 超时则重传FIN
5. 收到有效ACK，退出

5.4 PLC模块集成

- 前向方向：所有出站段（DATA/SYN/FIN）通过process_forward()
- 反向方向：所有入站ACK通过process_reverse()
- URP协议对PLC操作无感知

================================================================================

6. 接收方操作

6.1 连接建立

1. 打开UDP套接字，进入LISTEN状态
2. 接收SYN段
3. 验证校验和
4. 发送ACK(ISN+1)，进入ESTABLISHED状态
5. 处理重复SYN时重新发送ACK

6.2 数据接收

段处理：
- 接收UDP数据报
- 解析并验证校验和
- 如果损坏则丢弃

按序交付：
- 如果seq_num == expected_seq：
  * 立即将载荷写入文件
  * 更新expected_seq
  * 检查缓冲区中是否有新连续数据
- 如果乱序：
  * 在buffer字典中缓冲段
  * 发送重复ACK

重复检测：
- 在received_bytes集合中跟踪已接收字节范围
- 丢弃重复段，不写入文件

6.3 连接终止

1. 接收FIN段
2. 发送FIN ACK
3. 进入TIME_WAIT状态（2秒）
4. TIME_WAIT期间：处理重传的FIN段
5. 超时后，进入CLOSED状态并退出

================================================================================

7. 设计权衡

7.1 单一定时器 vs 每段定时器

选择：为最老的未确认段使用单一定时器

理由：
- 实现更简单，符合TCP行为
- 减少内存开销
- 权衡：单个段的超时精度较低（本作业可接受）

7.2 基于字典的缓冲

选择：使用Python字典作为段缓冲区

理由：
- 高效的O(1)操作
- 易于实现滑动窗口
- 权衡：内存使用随窗口大小增长（在max_win约束下可接受）

7.3 增量文件I/O

选择：增量读写文件，而非一次性读取

理由：
- 高效处理大文件
- 减少内存占用
- 权衡：文件位置跟踪更复杂（作业要求必需）

7.4 多线程

选择：为定时器管理使用独立线程

理由：
- 职责分离清晰
- 防止套接字操作阻塞
- 权衡：需要仔细同步（使用锁处理）

================================================================================

8. 实现挑战与解决方案

8.1 快速重传逻辑

挑战：正确识别何时快速重传

解决方案：按ACK号跟踪重复ACK计数，对base段的第3个重复时重传

8.2 TIME_WAIT状态

挑战：接收方必须在TIME_WAIT期间处理重传的FIN段

解决方案：在TIME_WAIT期间保持套接字打开并监听，收到重传FIN时重启定时器

8.3 统计准确性

挑战：区分原始传输和重传

解决方案：发送段时跟踪is_retransmission标志，相应更新统计信息

8.4 序列号回绕

挑战：处理16位序列号溢出

解决方案：一致使用模运算（seq_num % 65536）

================================================================================

9. 借用代码

没有直接从外部来源借用代码。实现从头开发，基于：

- 作业规范（Assignment_v1.3.pdf）
- 课程材料中的TCP协议概念
- 标准Python套接字编程模式

校验和算法遵循网络教科书（如Kurose & Ross）中描述的标准反码方法，但独立实现。

================================================================================

10. 测试

实现已通过以下测试：

- 测试1：可靠信道上的停等协议
- 测试2：有丢包/损坏的停等协议
- 测试3：可靠信道上的滑动窗口
- 测试4：有丢包/损坏的滑动窗口

所有测试均成功通过，文件传输正确，日志生成准确。

================================================================================

11. 已知限制

无。实现完全满足所有作业要求，正确处理所有指定场景。
